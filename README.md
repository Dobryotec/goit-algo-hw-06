# Порівняння алгоритмів пошуку в графі

Цей проект демонструє реалізацію алгоритмів пошуку в глибину (DFS) та пошуку в ширину (BFS) на орієнтованому графі. Граф створено за допомогою бібліотеки NetworkX, і відмінності між шляхами, знайденими за допомогою DFS та BFS, висвітлено та пояснено.

## Структура графа

Граф, використаний у цьому проекті, складається з шести вузлів та кількох орієнтованих ребер. Вузли представляють індивідів, а ребра – взаємовідносини між ними. Ось структура графа:

### Вузли:

- human1
- human2
- human3
- human4
- human5
- human6

### Ребра:

- human1 -> human2
- human1 -> human5
- human2 -> human3
- human3 -> human4
- human2 -> human1
- human3 -> human2
- human4 -> human3
- human5 -> human6
- human6 -> human1

## Алгоритми DFS та BFS

### Пошук в глибину (DFS)

DFS досліджує кожну гілку до максимальної глибини, перш ніж повернутися назад. Використовує підхід на основі стека, через рекурсію або явний стек.

### Пошук в ширину (BFS)

BFS досліджує всі сусідні вузли на поточній глибині, перш ніж переходити до вузлів на наступному рівні глибини. Використовує чергу для відстеження вузлів, які потрібно дослідити.

## Порівняння шляхів DFS та BFS

### Шлях DFS:

`human1 human2 human3 human4 human5 human6`

- **Пояснення:** DFS проходить максимально глибоко від **human1** до **human4** перед тим, як повернутися назад і досліджувати інші гілки.

### Шлях BFS:

`human1 human2 human5 human3 human6 human4`

- **Пояснення:** BFS спочатку досліджує всіх сусідів **human1** (**human2** та **human5**), потім переходить до їхніх сусідів (**human3** та **human6**) і так далі. Це забезпечує, що всі вузли на кожному рівні досліджуються перед тим, як рухатися глибше.

## Висновок

Шляхи, знайдені за допомогою DFS та BFS, різняться через їхні фундаментальні відмінності в підходах:

- **DFS** зосереджується на глибині, досліджуючи гілку до максимальної глибини перед поверненням назад.
- **BFS** зосереджується на ширині, досліджуючи всі вузли на поточній глибині перед переходом до наступного рівня.
